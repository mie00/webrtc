<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Styled Page</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="min-h-screen flex items-stretch justify-center bg-gray-100 p-4">
    <div class="flex w-full h-full space-x-4">
        <div class="flex-1 h-full flex flex-col space-y-4">
            <p id="stat" class="text-lg text-center mb-4"></p>
            <div class="flex-1" id="handshake">
				<button id="button" onclick="createOffer()" class="w-full py-2 px-4 bg-blue-500 text-white rounded shadow hover:bg-blue-700">Offer</button>
				<textarea id="offer" class="w-full h-full p-2 border rounded" placeholder="Paste offer here. And press Enter"></textarea>
                <label for="answer" class="block text-gray-700">Answer:</label>
                <textarea id="answer" class="w-full h-full p-2 border rounded"></textarea>
            </div>
			<div id="comm" class="hidden">
				<label for="fileUpload" class="block text-gray-700">Upload/Drop File:</label>
				
				<div id="dropArea" class="w-full p-4 border-dashed border-2 border-gray-300 text-center rounded mb-4">
					Drop file here or Upload <input id="fileUpload" type="file" class="p-2 border rounded mb-4">
				</div>
				<div id="progress_parent" class="max-w-lg mx-auto bg-gray-200 p-4 rounded hidden">
					<h2 class="text-lg font-semibold mb-2">Progress Bar</h2>
					<div id="progressBar" class="bg-blue-500 h-5 rounded relative mb-2">
						<div id="progressIndicator" class="h-full bg-green-500"></div>
						<div id="progressText" class="text-white font-bold absolute top-0 left-0 w-full h-full flex items-center justify-center pointer-events-none">0%</div>
					</div>
				</div>
				<div id="file_resp" class="hidden">
					<span id="filename"></span>
					<a id="download" class="w-full py-2 px-4 bg-blue-500 text-white rounded shadow hover:bg-blue-700">Download</a>
					<a id="view" class="w-full py-2 px-4 bg-blue-500 text-white rounded shadow hover:bg-blue-700" target="_blank">View</a>
				</div>
            <div>
                <label for="chat" class="block text-gray-700">Chat:</label>
                <input id="chat" class="w-full p-2 border rounded">
            </div>
            <pre id="output" class="w-full flex-1 p-2 border rounded bg-white">Chat:</pre>
			</div>
			<div id="videoContainer" class="flex w-full">
				<div class="w-1/2 aspect-w-1 aspect-h-1 bg-gray-200 rounded overflow-hidden">
					<video id="video1" class="w-full object-cover rounded"></video>
				</div>
				<div class="w-1/2 aspect-w-1 aspect-h-1 bg-gray-200 rounded overflow-hidden">
					<video id="video2" class="w-full object-cover rounded"></video>
				</div>
			</div>
        </div>
		<div class="w-1/3 h-full flex flex-col">
			<button id="toggleSettings" onclick="toggleSettings()" class="w-full py-2 px-4 bg-gray-500 text-white rounded shadow hover:bg-gray-700">Settings</button>
			<div id="settingsPanel" class="mt-4 p-4 border rounded bg-white flex-1 hidden overflow-auto">
				<div class="mb-4">
					<label for="stunServers" class="block text-gray-700">STUN Servers:</label>
					<input id="stunServers" class="w-full p-2 border rounded" placeholder="STUN server URLs" value="stun.l.google.com:19302">
				</div>
                <div class="mb-4">
                    <label class="block text-gray-700">Video:</label>
                    <select id="mediaType" class="w-full p-2 border rounded">
                        <option value="none">None</option>
                        <option value="audio">Audio</option>
                        <option value="video">Video</option>
                        <option value="screen">Screen</option>
                    </select>
                </div>
			</div>
		</div>
    </div>

	<div id="overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
		<p class="text-4xl text-white">send this link over: </p>
		<p id="link" class="break-all text-4xl text-white font-bold underline"></p>
		<button class="text-4xl text-white font-bold" id="link-btn">Copy</button>
		<br />
		<input id="nego-answer" placeholder="paste answer here and press button"><button id="link-btn2">Accept answer</button>
	</div>
	<script>
		function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            settingsPanel.classList.toggle('hidden');
        }
		const output = document.getElementById('output');
		const app = {};
        const handshakeSection = document.getElementById('handshake');



		function updateProgressBar(file_size, get_ready) {
			document.getElementById('progress_parent').classList.remove('hidden');
			const progressBar = document.getElementById('progressBar');
			const progressIndicator = document.getElementById('progressIndicator');
			const progressText = document.getElementById('progressText');

			const bufferedAmount = get_ready();

			// Calculate progress percentage (0 to 100)
			const progressPercentage = (file_size - bufferedAmount) / file_size * 100;

			// Update width of progressIndicator based on progressPercentage
			progressIndicator.style.width = `${progressPercentage}%`;

			progressText.textContent = `${progressPercentage}%`;
			// Change progress bar color to green when bufferedAmount reaches 0
			if (bufferedAmount === 0) {
				progressBar.classList.remove('bg-blue-500');
				progressBar.classList.add('bg-green-500');
				clearInterval(app.file_progress_interval);
			} else {
				progressBar.classList.remove('bg-green-500');
				progressBar.classList.add('bg-blue-500');
			}
		}

		let localStream;

		async function initMedia() {
			if (localStream) {
				localStream.getTracks().forEach(function(track) {
					track.stop();
				});
			}
			if (app.stream_type == 'audio' || app.stream_type == 'video') {
				localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: app.stream_type == 'video' });
				const localPlayer = document.getElementById('video1');
				localPlayer.srcObject = localStream;
				localPlayer.muted = true;
				localPlayer.onloadedmetadata = () => {
					localPlayer.play();
				};
				localPlayer.height = localPlayer.clientHeight.toString() + 'px';
			} else if (app.stream_type == 'screen') {
				localStream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: {cursor: "always"} });
				const localPlayer = document.getElementById('video1');
				localPlayer.srcObject = localStream;
				localPlayer.muted = true;
				localPlayer.onloadedmetadata = () => {
					localPlayer.play();
				};
				localPlayer.height = localPlayer.clientHeight.toString() + 'px';
			} else {
				localStream = null;
			}

			if (localStream && app.pc) {
				console.log("ASDASDASDASDASD")
				localStream.getTracks().forEach((track) => {
					app.pc.addTrack(track, localStream);
				});
			}
		}

		// Add event listener to detect changes on the select element
		document.getElementById('mediaType').addEventListener('change', async function() {
			app.stream_type = this.value;
			await initMedia();
		});

		async function init() {
			const config = {
				iceServers: document.getElementById("stunServers").value.split(',').filter(link => link).map(link => ({urls: "stun:" + link})),
			};

			const pc = new RTCPeerConnection(config);
			app.pc = pc;
			const nego_dc = pc.createDataChannel("nego", {
				negotiated: true,
				id: 0
			});
			app.nego_dc = nego_dc;
			nego_dc.onopen = () => {
				handshakeSection.classList.add('hidden');
				document.getElementById("overlay").classList.add('hidden');
			};

			if (localStream && app.pc) {
				localStream.getTracks().forEach((track) => {
					console.log("tracks", track)
					app.pc.addTrack(track, localStream);
				});
			}

			app.pc.addEventListener("track", (ev) => {
				const video = document.getElementById('video2');
				video.srcObject = ev.streams[0];

				video.onloadedmetadata = () => {
					video.play();
				};
			})

			nego_dc.onmessage = async e => {
				const data = JSON.parse(e.data);
				pc.setRemoteDescription(data);
				if (data.type === "offer") {
					await pc.setLocalDescription();
					nego_dc.send(JSON.stringify(pc.localDescription));
				}
			};
			if (true) {
				const dc = pc.createDataChannel("chat", {
					negotiated: true,
					id: 1
				});
				app.dc = dc;
				dc.onopen = () => {
					document.getElementById('comm').classList.remove('hidden');
					chat.select();
				};
				dc.onmessage = e => log(`> ${e.data}`);
				pc.oniceconnectionstatechange = e => log(pc.iceConnectionState);

				pc.onconnectionstatechange = ev => handleChange();
				pc.oniceconnectionstatechange = ev => handleChange();

				const dc_file = pc.createDataChannel("file", {
					negotiated: true,
					id: 2
				});
				app.dc_file = dc_file;

				dc_file.onmessage = e => {
					if (!app.file_stuff) {
						app.file_stuff = JSON.parse(e.data);
						app.file_stuff.segments = [];
						app.file_stuff.remaining_size = app.file_stuff.size;
						updateProgressBar(app.file_stuff.size, () => app.file_stuff.remaining_size);
						return
					}
					app.file_stuff.segments.push(e.data);
					app.file_stuff.remaining_size -= e.data.byteLength;
					updateProgressBar(app.file_stuff.size, () => app.file_stuff.remaining_size);
					if (app.file_stuff.remaining_size === 0) {
						const blob = new Blob(app.file_stuff.segments, { type: app.file_stuff.type });
						const url = URL.createObjectURL(blob);
						document.getElementById('filename').innerHTML = app.file_stuff.name;
						const file_resp = document.getElementById('file_resp');
						const a = document.getElementById("download");
						a.href = url;
						a.download = app.file_stuff.name;
						a.addEventListener('click', (ev) => {
							file_resp.classList.toggle("hidden");
						});
						const aview = document.getElementById("view")
						aview.href = url;
						aview.addEventListener('click', (ev) => {
							// file_resp.classList.toggle("hidden");
						});
						file_resp.classList.remove("hidden");
						app.file_stuff = null;
					}
				};
			}

		}
		const log = msg => output.innerHTML += `<br>${msg}`;
		chat.onkeypress = function (e) {
			if (e.keyCode != 13) return;
			app.dc.send(chat.value);
			log(chat.value);
			chat.value = "";
		};

		async function getOffer(cb) {
			await init();
			await app.pc.setLocalDescription(await app.pc.createOffer());

			app.pc.onnegotiationneeded = async function() {
				const offer = await app.pc.createOffer()
				await app.pc.setLocalDescription(offer);
				app.nego_dc.send(JSON.stringify(offer));
			};
			app.pc.onicecandidate = async ({
				candidate
			}) => {
				console.log('Candidate found', candidate)
				if (candidate && candidate.type !== 'srflx') return;
				await cb(app.pc.localDescription.sdp);
			};
		}

		async function createOffer() {
			button.disabled = true;
			await getOffer((sdp) => {
				offer.value = sdp;
				offer.select();
				answer.placeholder = "Paste answer here. And Press Enter";
			})
		}

		async function getAnswer(offer, cb) {
			await init();
			await app.pc.setRemoteDescription({
				type: "offer",
				sdp: offer.trim() + '\n'
			});
			await app.pc.setLocalDescription(await app.pc.createAnswer());

			app.pc.onnegotiationneeded = async function() {
				const offer = await app.pc.createOffer()
				await app.pc.setLocalDescription(offer);
				app.nego_dc.send(JSON.stringify(offer));
			};
			app.pc.onicecandidate = async ({
				candidate
			}) => {
				if (candidate && candidate.type !== 'srflx') return;
				await cb(app.pc.localDescription.sdp)
			};
		}

		offer.onkeypress = async function (e) {
			if (e.keyCode != 13) return;
			button.disabled = offer.disabled = true;
			
			await getAnswer(offer.value, (sdp) => {
				answer.focus();
				answer.value = sdp;
				answer.select();
			});
		};

		answer.onkeypress = function (e) {
			if (e.keyCode != 13 || app.pc.signalingState != "have-local-offer") return;
			answer.disabled = true;
			app.pc.setRemoteDescription({
				type: "answer",
				sdp: answer.value.trim() + '\n'
			});
		};


		function handleChange() {
			let stat = 'ConnectionState: <strong>' + app.pc?.connectionState + '</strong> IceConnectionState: <strong>' + app.pc?.iceConnectionState + '</strong>';
			document.getElementById('stat').innerHTML = stat;
			console.log('%c' + new Date().toISOString() + ': ConnectionState: %c' + app.pc?.connectionState + ' %cIceConnectionState: %c' + app.pc?.iceConnectionState,
				'color:yellow', 'color:orange', 'color:yellow', 'color:orange');
		}
		handleChange();







		document.getElementById('fileUpload').addEventListener('change', handleFileSelect);
		document.getElementById('dropArea').addEventListener('dragover', handleDragOver);
		document.getElementById('dropArea').addEventListener('drop', handleFileDrop);

		function handleFileSelect(event) {
			const file = event.target.files[0];
			readFile(file);
		}

		function handleDragOver(event) {
			event.preventDefault();
			event.stopPropagation();
			event.dataTransfer.dropEffect = 'copy';
		}

		function handleFileDrop(event) {
			event.preventDefault();
			event.stopPropagation();
			const file = event.dataTransfer.files[0];
			readFile(file);
		}
		function splitArrayBuffer(arrayBuffer, chunkSize) {
			const uint8Array = new Uint8Array(arrayBuffer);
			const chunks = [];
			let offset = 0;

			while (offset < uint8Array.length) {
				const chunk = uint8Array.slice(offset, offset + chunkSize);
				chunks.push(chunk.buffer);  // Push the ArrayBuffer of the chunk
				offset += chunkSize;
			}

			return chunks;
		}

		function readFile(file) {
			let offset = 0;
			const max_size = 2*1024*1024;
			var sent_header = false;
			const reader = new FileReader();
			reader.onload = function(event) {
				if (!sent_header) {
					app.dc_file.send(JSON.stringify({name: file.name, type: file.type, size: file.size}));
					sent_header = true;
				}
				for (var chunk of splitArrayBuffer(event.target.result, 128*1024)) {
					app.dc_file.send(chunk);
				}
				app.file_progress_interval = setInterval(updateProgressBar.bind(null, file.size, () => app.dc_file.bufferedAmount + (file.size - Math.min(offset, file.size))), 100)
			};
			var buffer_cb = (event) => {
				reader.readAsArrayBuffer(file.slice(offset, offset+max_size));
				offset += max_size;
				if (offset > file.size) {
					app.dc_file.removeEventListener("bufferedamountlow", buffer_cb);
				}
			};
			if (file.size > max_size) {
				app.dc_file.addEventListener("bufferedamountlow", buffer_cb);
			}
			reader.readAsArrayBuffer(file.slice(offset, offset+max_size));
			offset += max_size;
		}
		// copied from https://gist.github.com/Explosion-Scratch/357c2eebd8254f8ea5548b0e6ac7a61b
		async function compress(string, encoding) {
			const byteArray = new TextEncoder().encode(string);
			const cs = new CompressionStream(encoding);
			const writer = cs.writable.getWriter();
			writer.write(byteArray);
			writer.close();
			const compressed = await new Response(cs.readable).arrayBuffer();
			return btoa(String.fromCharCode(...new Uint8Array(compressed)));
		}

		async function decompress(byteArray, encoding) {
			const compressedBuffer = Uint8Array.from(atob(byteArray), c => c.charCodeAt(0));
			const cs = new DecompressionStream(encoding);
			const writer = cs.writable.getWriter();
			writer.write(compressedBuffer);
			writer.close();
			// console.log("ZZZZZZZZZAS", new Response(cs.readable).clone().arrayBuffer().catch(console.log));
			const arrayBuffer = await (new Response(cs.readable).arrayBuffer());
			console.log("ZZZZZZZZZAS");
			return new TextDecoder().decode(arrayBuffer);
		}
		const urlParams = new URLSearchParams(window.location.search);
		const windowLoader = async () => {
			window.removeEventListener("load", windowLoader);
			if (!urlParams.get('offer')) {
				await getOffer(async (sdp) => {
					const link = document.getElementById('link');
					link.parentElement.classList.remove('hidden');
					const compressed = await compress(sdp, "gzip");
					urlParams.set('offer', compressed);
					window.history.pushState("", "", '?' +  urlParams.toString());
					link.innerHTML = window.location;
					const btn = document.getElementById("link-btn");
					btn.innerHTML = "Copy";
					btn.addEventListener("click", (ev) => {
						navigator.clipboard?.writeText(window.location);
					})
					const btn2 = document.getElementById("link-btn2");
					btn2.addEventListener("click", async (ev) => {
						const answer = await decompress(document.getElementById('nego-answer').value, "gzip");
						app.pc.setRemoteDescription({
							type: "answer",
							sdp: answer.trim() + '\n'
						});
						link.parentElement.classList.add('hidden');
					})
				})
			} else {
				const offer = await decompress(urlParams.get('offer'), "gzip");
				await getAnswer(offer, async (sdp) => {
					const link = document.getElementById('link');
					link.parentElement.classList.remove('hidden');
					const compressed = await compress(sdp, "gzip");
					link.innerHTML = compressed;
					const btn = document.getElementById("link-btn");
					btn.innerHTML = "Copy and start";
					btn.addEventListener("click", (ev) => {
						navigator.clipboard?.writeText(window.location);
						link.parentElement.classList.add('hidden');
					})
				})
			}
		}
		window.addEventListener("load", windowLoader);


	</script>
</body>

</html>
